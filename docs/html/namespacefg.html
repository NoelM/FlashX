<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>FlashGraph-ng: fg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FlashGraph-ng
   </div>
   <div id="projectbrief">A new frontier in large-scale graph analysis and data mining</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">fg Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Compute kmeans on matrix of features.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FlashGraph vector that provides several parallelized methods when compared to an STL-vector. <br/>
 <b>NOTE</b>: Not an STL-compatible data structure. This vector is also ideally used with numeric data types. <br/>
 Methods marked with the keyword <b>parallel</b> are parallelized implementations.  <a href="classfg_1_1FG__vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1FG__graph.html">FG_graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A user-friendly wrapper for FlashGraph's raw graph type. Very usefule when when utilizing FlashGraph pre-written/library algorithms.  <a href="classfg_1_1FG__graph.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1graph__config.html">graph_config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1compute__vertex.html">compute_vertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class from which users' vertex-centric programs should inherit. Serial code written when implementing <em>run*</em>. methods here will be run in parallel within the graph engine.  <a href="classfg_1_1compute__vertex.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1compute__directed__vertex.html">compute_directed_vertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A directed version of the <code><a class="el" href="classfg_1_1compute__vertex.html" title="Class from which users&#39; vertex-centric programs should inherit. Serial code written when implementing...">compute_vertex</a></code> class that users inherit from when using the FlashGraph engine.  <a href="classfg_1_1compute__directed__vertex.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1vertex__scheduler.html">vertex_scheduler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1vertex__filter.html">vertex_filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">When the graph engine starts, a user can use this filter to decide what vertices are activated for the first time.  <a href="classfg_1_1vertex__filter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1vertex__initializer.html">vertex_initializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A user may be decide to initialize individual vertex state in a custom way not expressible via the vertex constructor. This provides that capability.  <a href="classfg_1_1vertex__initializer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1vertex__query.html">vertex_query</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallized query of the vertex state of all vertices in the graph. Each worker thread gets an instance of the query and the per-thread query results will be merged in the end. Inherit from this class to run queries in parallel.  <a href="classfg_1_1vertex__query.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1graph__engine.html">graph_engine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the class that coordinates how &amp; where algorithms are run. It can be seen as the central organ of FlashGraph.  <a href="classfg_1_1graph__engine.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1graph__header.html">graph_header</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1graph__index.html">graph_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file contains a set of graph index implementation. The graph index is the in-memory container to keep all vertices of a graph. <br/>
  <a href="classfg_1_1graph__index.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1vertex__message.html">vertex_message</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfg_1_1local__vid__t.html">local_vid_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1ts__edge__data.html">ts_edge_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1edge__count.html">edge_count</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1page__vertex.html">page_vertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex representation when in the page cache.  <a href="classfg_1_1page__vertex.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1TS__page__vertex.html">TS_page_vertex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1page__directed__vertex.html">page_directed_vertex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1page__undirected__vertex.html">page_undirected_vertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This vertex class represents an undirected vertex in the page cache.  <a href="classfg_1_1page__undirected__vertex.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1vertex__program.html">vertex_program</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1vertex__program__creater.html">vertex_program_creater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend/Override when defining a custom vertex program. The graph engine uses this to construct vertex programs for each worker thread.  <a href="classfg_1_1vertex__program__creater.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1vertex__program__impl.html">vertex_program_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default implementation of a vertex program in the graph engine.  <a href="classfg_1_1vertex__program__impl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1ts__vertex__request.html">ts_vertex_request</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac4c90ec30f4ed5fda99401fc225d9bf2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4c90ec30f4ed5fda99401fc225d9bf2"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#ac4c90ec30f4ed5fda99401fc225d9bf2">vsize_t</a></td></tr>
<tr class="memdesc:ac4c90ec30f4ed5fda99401fc225d9bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic data types used in FlashGraph. <br/></td></tr>
<tr class="separator:ac4c90ec30f4ed5fda99401fc225d9bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4bf4a3b1a282d7e21d4eeb79d15589"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; int, struct <br class="typebreak"/>
<a class="el" href="structfg_1_1local__vid__t.html">local_vid_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#a5d4bf4a3b1a282d7e21d4eeb79d15589">vertex_loc_t</a></td></tr>
<tr class="separator:a5d4bf4a3b1a282d7e21d4eeb79d15589"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2e20d2962139da47af618f4a3959e370"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#a2e20d2962139da47af618f4a3959e370">directed_triangle_type</a> </td></tr>
<tr class="memdesc:a2e20d2962139da47af618f4a3959e370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangle computation type.  <a href="namespacefg.html#a2e20d2962139da47af618f4a3959e370">More...</a><br/></td></tr>
<tr class="separator:a2e20d2962139da47af618f4a3959e370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8871eb2796bb816f20a4a8538978b0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#a7a8871eb2796bb816f20a4a8538978b0">edge_type</a> { , <a class="el" href="namespacefg.html#a7a8871eb2796bb816f20a4a8538978b0a3bd48ace4a0a76ac675621975cb2825c">IN_EDGE</a>, 
<a class="el" href="namespacefg.html#a7a8871eb2796bb816f20a4a8538978b0a0b88ddc95dc0b775363ebc027e20e0dc">OUT_EDGE</a>, 
<a class="el" href="namespacefg.html#a7a8871eb2796bb816f20a4a8538978b0ade7c0227ef329a4fa22c8433dedadae6">BOTH_EDGES</a>, 
<a class="el" href="namespacefg.html#a7a8871eb2796bb816f20a4a8538978b0a31b588a35d7e269dff6450ac0f6fa4f2">NUM_TYPES</a>
 }</td></tr>
<tr class="memdesc:a7a8871eb2796bb816f20a4a8538978b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge type of an edge in the graph.  <a href="namespacefg.html#a7a8871eb2796bb816f20a4a8538978b0">More...</a><br/></td></tr>
<tr class="separator:a7a8871eb2796bb816f20a4a8538978b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abaa69bd003d3e8195c04a9ec16f3b0db"><td class="memTemplParams" colspan="2">template&lt;class T , class ApplyFunc &gt; </td></tr>
<tr class="memitem:abaa69bd003d3e8195c04a9ec16f3b0db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefg.html#abaa69bd003d3e8195c04a9ec16f3b0db">multi_vec_apply</a> (const std::vector&lt; typename <a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt; T &gt;::ptr &gt; &amp;inputs, typename <a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt; T &gt;::ptr output, ApplyFunc apply)</td></tr>
<tr class="memdesc:abaa69bd003d3e8195c04a9ec16f3b0db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a user defined function to multipl FG_vectors. <b>parallel</b>  <a href="#abaa69bd003d3e8195c04a9ec16f3b0db">More...</a><br/></td></tr>
<tr class="separator:abaa69bd003d3e8195c04a9ec16f3b0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a08b5c608b7450cf964c5bb1128c935"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt; vertex_id_t &gt;::ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#a3a08b5c608b7450cf964c5bb1128c935">compute_wcc</a> (FG_graph::ptr fg)</td></tr>
<tr class="memdesc:a3a08b5c608b7450cf964c5bb1128c935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all weakly connectected components of a graph.  <a href="#a3a08b5c608b7450cf964c5bb1128c935">More...</a><br/></td></tr>
<tr class="separator:a3a08b5c608b7450cf964c5bb1128c935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096477f39527cdc1feaf88b52a549b8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt; vertex_id_t &gt;::ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#a096477f39527cdc1feaf88b52a549b8a">compute_sync_wcc</a> (FG_graph::ptr fg)</td></tr>
<tr class="memdesc:a096477f39527cdc1feaf88b52a549b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all weakly connectected components of a graph synchronously. The reason of having this implementation is to understand the performance of synchronous wcc and asynchronous wcc.  <a href="#a096477f39527cdc1feaf88b52a549b8a">More...</a><br/></td></tr>
<tr class="separator:a096477f39527cdc1feaf88b52a549b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdbe4bcd2f983ca595d76a021a555b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt; vertex_id_t &gt;::ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#a2cdbe4bcd2f983ca595d76a021a555b5">compute_ts_wcc</a> (FG_graph::ptr fg, time_t start_time, time_t time_interval)</td></tr>
<tr class="memdesc:a2cdbe4bcd2f983ca595d76a021a555b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all weakly connectected components of a time-series graph in a specified time interval.  <a href="#a2cdbe4bcd2f983ca595d76a021a555b5">More...</a><br/></td></tr>
<tr class="separator:a2cdbe4bcd2f983ca595d76a021a555b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d31b75e022b9784cade8eec88fe76fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt; vertex_id_t &gt;::ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#a5d31b75e022b9784cade8eec88fe76fe">compute_scc</a> (FG_graph::ptr fg)</td></tr>
<tr class="memdesc:a5d31b75e022b9784cade8eec88fe76fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all strongly connected components of a graph.  <a href="#a5d31b75e022b9784cade8eec88fe76fe">More...</a><br/></td></tr>
<tr class="separator:a5d31b75e022b9784cade8eec88fe76fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae183a657035f3cf50fedc43ee4890106"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt; size_t &gt;::ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#ae183a657035f3cf50fedc43ee4890106">compute_directed_triangles</a> (FG_graph::ptr fg, <a class="el" href="namespacefg.html#a2e20d2962139da47af618f4a3959e370">directed_triangle_type</a> type)</td></tr>
<tr class="memdesc:ae183a657035f3cf50fedc43ee4890106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the directed triangle count for each each vertex. Currently, it only counts the number of cycle triangles.  <a href="#ae183a657035f3cf50fedc43ee4890106">More...</a><br/></td></tr>
<tr class="separator:ae183a657035f3cf50fedc43ee4890106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51df06096e9cca18fb17faf00f32786a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt; size_t &gt;::ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#a51df06096e9cca18fb17faf00f32786a">compute_undirected_triangles</a> (FG_graph::ptr fg)</td></tr>
<tr class="memdesc:a51df06096e9cca18fb17faf00f32786a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute undirected triangle count for each vertex.  <a href="#a51df06096e9cca18fb17faf00f32786a">More...</a><br/></td></tr>
<tr class="separator:a51df06096e9cca18fb17faf00f32786a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793a72517715e336027303a530262e15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt; size_t &gt;::ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#a793a72517715e336027303a530262e15">compute_local_scan</a> (FG_graph::ptr)</td></tr>
<tr class="memdesc:a793a72517715e336027303a530262e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the per-vertex local Scan Statistic.  <a href="#a793a72517715e336027303a530262e15">More...</a><br/></td></tr>
<tr class="separator:a793a72517715e336027303a530262e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2051de108cc335b094326fff4f0f1f5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt; std::pair<br class="typebreak"/>
&lt; vertex_id_t, size_t &gt; &gt;::ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#a2051de108cc335b094326fff4f0f1f5f">compute_topK_scan</a> (FG_graph::ptr, size_t topK)</td></tr>
<tr class="memdesc:a2051de108cc335b094326fff4f0f1f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the top K vertices with the largest local Scan Statistic value.  <a href="#a2051de108cc335b094326fff4f0f1f5f">More...</a><br/></td></tr>
<tr class="separator:a2051de108cc335b094326fff4f0f1f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e5648d53863c4e07cddb792ba52d60"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#a53e5648d53863c4e07cddb792ba52d60">estimate_diameter</a> (FG_graph::ptr fg, int num_bfs, bool directed)</td></tr>
<tr class="memdesc:a53e5648d53863c4e07cddb792ba52d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the diameter estimation for a graph.  <a href="#a53e5648d53863c4e07cddb792ba52d60">More...</a><br/></td></tr>
<tr class="separator:a53e5648d53863c4e07cddb792ba52d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e08e9f37c6433c7a77c1fdc6f05ca32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt; float &gt;::ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#a0e08e9f37c6433c7a77c1fdc6f05ca32">compute_pagerank</a> (FG_graph::ptr fg, int num_iters, float damping_factor)</td></tr>
<tr class="memdesc:a0e08e9f37c6433c7a77c1fdc6f05ca32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the PageRank of a graph using the pull method where vertices request the data from all their neighbors each iteration. Tends to converge to stable values.  <a href="#a0e08e9f37c6433c7a77c1fdc6f05ca32">More...</a><br/></td></tr>
<tr class="separator:a0e08e9f37c6433c7a77c1fdc6f05ca32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc8c4d461a9c7f3b5bedb7627851925"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt; float &gt;::ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#a6fc8c4d461a9c7f3b5bedb7627851925">compute_pagerank2</a> (FG_graph::ptr, int num_iters, float damping_factor)</td></tr>
<tr class="memdesc:a6fc8c4d461a9c7f3b5bedb7627851925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the PageRank of a graph using the push method where vertices send deltas of their PageRank to neighbors in the event their own PageRank changes.  <a href="#a6fc8c4d461a9c7f3b5bedb7627851925">More...</a><br/></td></tr>
<tr class="separator:a6fc8c4d461a9c7f3b5bedb7627851925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b00d34d28ae5c8b26ab407e7e9a166a"><td class="memItemLeft" align="right" valign="top">in_mem_subgraph::ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#a6b00d34d28ae5c8b26ab407e7e9a166a">fetch_subgraph</a> (FG_graph::ptr graph, const std::vector&lt; vertex_id_t &gt; &amp;vertices)</td></tr>
<tr class="memdesc:a6b00d34d28ae5c8b26ab407e7e9a166a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the clusters with the wanted cluster IDs.  <a href="#a6b00d34d28ae5c8b26ab407e7e9a166a">More...</a><br/></td></tr>
<tr class="separator:a6b00d34d28ae5c8b26ab407e7e9a166a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa74e6ba209185dbebe3e0ae9965218"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt; size_t &gt;::ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#acaa74e6ba209185dbebe3e0ae9965218">compute_kcore</a> (FG_graph::ptr fg, size_t k, size_t kmax=0)</td></tr>
<tr class="memdesc:acaa74e6ba209185dbebe3e0ae9965218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the k-core/coreness of a graph. The algorithm will determine which vertices are between core <code>k</code> and <code>kmax</code> &ndash; all other vertices will be assigned to core 0.  <a href="#acaa74e6ba209185dbebe3e0ae9965218">More...</a><br/></td></tr>
<tr class="separator:acaa74e6ba209185dbebe3e0ae9965218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf654728e855f5cd5d33e05ce73a1a8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt; <a class="el" href="namespacefg.html#ac4c90ec30f4ed5fda99401fc225d9bf2">vsize_t</a> &gt;::ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#abf654728e855f5cd5d33e05ce73a1a8e">get_degree</a> (FG_graph::ptr fg, <a class="el" href="namespacefg.html#a7a8871eb2796bb816f20a4a8538978b0">edge_type</a> type)</td></tr>
<tr class="memdesc:abf654728e855f5cd5d33e05ce73a1a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the degree of all vertices in the graph.  <a href="#abf654728e855f5cd5d33e05ce73a1a8e">More...</a><br/></td></tr>
<tr class="separator:abf654728e855f5cd5d33e05ce73a1a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8064fce1e91f417fb4128671c6f893f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt; float &gt;::ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#a8064fce1e91f417fb4128671c6f893f7">compute_transitivity</a> (FG_graph::ptr fg)</td></tr>
<tr class="memdesc:a8064fce1e91f417fb4128671c6f893f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the transitivity/clustering coefficient of a graph.  <a href="#a8064fce1e91f417fb4128671c6f893f7">More...</a><br/></td></tr>
<tr class="separator:a8064fce1e91f417fb4128671c6f893f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae746baf1ed5cc7f8fe99be410ee5e0f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt; float &gt;::ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#ae746baf1ed5cc7f8fe99be410ee5e0f7">compute_betweenness_centrality</a> (FG_graph::ptr fg, const std::vector&lt; vertex_id_t &gt; &amp;vids)</td></tr>
<tr class="memdesc:ae746baf1ed5cc7f8fe99be410ee5e0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the betweeenness centrality of a graph.  <a href="#ae746baf1ed5cc7f8fe99be410ee5e0f7">More...</a><br/></td></tr>
<tr class="separator:ae746baf1ed5cc7f8fe99be410ee5e0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8209ca51960ec08cbe98ce3e9678326"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt; <a class="el" href="namespacefg.html#ac4c90ec30f4ed5fda99401fc225d9bf2">vsize_t</a> &gt;::ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#ab8209ca51960ec08cbe98ce3e9678326">get_ts_degree</a> (FG_graph::ptr fg, <a class="el" href="namespacefg.html#a7a8871eb2796bb816f20a4a8538978b0">edge_type</a> type, time_t start_time, time_t time_interval)</td></tr>
<tr class="memdesc:ab8209ca51960ec08cbe98ce3e9678326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the degree of all vertices in a specified time interval in a time-series graph.  <a href="#ab8209ca51960ec08cbe98ce3e9678326">More...</a><br/></td></tr>
<tr class="separator:ab8209ca51960ec08cbe98ce3e9678326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87d33a7fb1ad68416eabade407ce556"><td class="memItemLeft" align="right" valign="top">std::pair&lt; time_t, time_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#ab87d33a7fb1ad68416eabade407ce556">get_time_range</a> (FG_graph::ptr fg)</td></tr>
<tr class="memdesc:ab87d33a7fb1ad68416eabade407ce556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time range in which the time-series graph is.  <a href="#ab87d33a7fb1ad68416eabade407ce556">More...</a><br/></td></tr>
<tr class="separator:ab87d33a7fb1ad68416eabade407ce556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e618817474e258ce639d1a88947f684"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#a1e618817474e258ce639d1a88947f684">compute_overlap</a> (FG_graph::ptr fg, const std::vector&lt; vertex_id_t &gt; &amp;vids, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;overlap_matrix)</td></tr>
<tr class="memdesc:a1e618817474e258ce639d1a88947f684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the neighborhood overlap of each pair of vertices in `vids'.  <a href="#a1e618817474e258ce639d1a88947f684">More...</a><br/></td></tr>
<tr class="separator:a1e618817474e258ce639d1a88947f684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf48ab2f1f7661c8069dc21f6f00f8d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#acf48ab2f1f7661c8069dc21f6f00f8d2">compute_louvain</a> (FG_graph::ptr fg, const uint32_t levels)</td></tr>
<tr class="memdesc:acf48ab2f1f7661c8069dc21f6f00f8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute louvain clustering for a graph.  <a href="#acf48ab2f1f7661c8069dc21f6f00f8d2">More...</a><br/></td></tr>
<tr class="separator:acf48ab2f1f7661c8069dc21f6f00f8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecd96672b421904a5a4d5413537da1f"><td class="memItemLeft" align="right" valign="top">sem_kmeans_ret::ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#a3ecd96672b421904a5a4d5413537da1f">compute_sem_kmeans</a> (FG_graph::ptr fg, const size_t k, const std::string init, const unsigned max_iters, const double tolerance)</td></tr>
<tr class="memdesc:a3ecd96672b421904a5a4d5413537da1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Semi-External Memory kmeans.  <a href="#a3ecd96672b421904a5a4d5413537da1f">More...</a><br/></td></tr>
<tr class="separator:a3ecd96672b421904a5a4d5413537da1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a40096428efe573d594aaaa9d031e3d45"><td class="memItemLeft" align="right" valign="top">const vertex_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefg.html#a40096428efe573d594aaaa9d031e3d45">MAX_VERTEX_ID</a> = UINT_MAX</td></tr>
<tr class="separator:a40096428efe573d594aaaa9d031e3d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Compute kmeans on matrix of features. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix who's row IDs are being clustered. </td></tr>
    <tr><td class="paramname">clusters</td><td>The cluster centers (means). </td></tr>
    <tr><td class="paramname">cluster_assignments</td><td>Which cluster each sample falls into. </td></tr>
    <tr><td class="paramname">cluster_assignment_counts</td><td>How many members each cluster has. </td></tr>
    <tr><td class="paramname">num_rows</td><td>The number of rows in <code>matrix</code>. </td></tr>
    <tr><td class="paramname">nev</td><td>The number of eigenvalues / number of columns in <code>matrix</code>. </td></tr>
    <tr><td class="paramname">k</td><td>The number of clusters required. </td></tr>
    <tr><td class="paramname">max_iters</td><td>The maximum number of iterations of K-means to perform. </td></tr>
    <tr><td class="paramname">init</td><td>The type of initilization ["random", "forgy", "kmeanspp"]</td></tr>
  </table>
  </dd>
</dl>
<p>Copyright 2014 Open Connectome Project (<a href="http://openconnecto.me">http://openconnecto.me</a>) Written by Da Zheng (<a href="#" onclick="location.href='mai'+'lto:'+'zhe'+'ng'+'da1'+'93'+'6@g'+'ma'+'il.'+'co'+'m'; return false;">zheng<span style="display: none;">.nosp@m.</span>da19<span style="display: none;">.nosp@m.</span>36@gm<span style="display: none;">.nosp@m.</span>ail.<span style="display: none;">.nosp@m.</span>com</a>)</p>
<p>This file is part of FlashGraph.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p>
<pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a5d4bf4a3b1a282d7e21d4eeb79d15589"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;int, struct <a class="el" href="structfg_1_1local__vid__t.html">local_vid_t</a>&gt; <a class="el" href="namespacefg.html#a5d4bf4a3b1a282d7e21d4eeb79d15589">fg::vertex_loc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The vertex location in a partition. first: the partition ID. second: the location in the partition. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a2e20d2962139da47af618f4a3959e370"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefg.html#a2e20d2962139da47af618f4a3959e370">fg::directed_triangle_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triangle computation type. </p>
<ul>
<li>CYCLE triangles are defined for directed graphs and depend on the direction of each edge. All edges must be head to tail connections. E.g A --&mdash;&gt; B ^ / | / | v C</li>
<li>ALL triangles. Edge direction is disregarded. E.g A --&mdash; B | / | / | / C </li>
</ul>

</div>
</div>
<a class="anchor" id="a7a8871eb2796bb816f20a4a8538978b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacefg.html#a7a8871eb2796bb816f20a4a8538978b0">fg::edge_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edge type of an edge in the graph. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a7a8871eb2796bb816f20a4a8538978b0a3bd48ace4a0a76ac675621975cb2825c"></a>IN_EDGE</em>&#160;</td><td class="fielddoc">
<p>No edge </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7a8871eb2796bb816f20a4a8538978b0a0b88ddc95dc0b775363ebc027e20e0dc"></a>OUT_EDGE</em>&#160;</td><td class="fielddoc">
<p>In edges </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7a8871eb2796bb816f20a4a8538978b0ade7c0227ef329a4fa22c8433dedadae6"></a>BOTH_EDGES</em>&#160;</td><td class="fielddoc">
<p>Out edges </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7a8871eb2796bb816f20a4a8538978b0a31b588a35d7e269dff6450ac0f6fa4f2"></a>NUM_TYPES</em>&#160;</td><td class="fielddoc">
<p>Both in and out edges </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae746baf1ed5cc7f8fe99be410ee5e0f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt;float&gt;::ptr fg::compute_betweenness_centrality </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; vertex_id_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the betweeenness centrality of a graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
    <tr><td class="paramname">vids</td><td>The vertex IDs for which BC should be computed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with an entry for each vertex in the graph's betweennesss centrality value. </dd></dl>

</div>
</div>
<a class="anchor" id="ae183a657035f3cf50fedc43ee4890106"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt;size_t&gt;::ptr fg::compute_directed_triangles </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">directed_triangle_type&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the directed triangle count for each each vertex. Currently, it only counts the number of cycle triangles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
    <tr><td class="paramname">type</td><td>The type of triangles you wish to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector that contains the number of triangles associated with each vertex in the graph. </dd></dl>

</div>
</div>
<a class="anchor" id="acaa74e6ba209185dbebe3e0ae9965218"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt;size_t&gt;::ptr fg::compute_kcore </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>kmax</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the k-core/coreness of a graph. The algorithm will determine which vertices are between core <code>k</code> and <code>kmax</code> &ndash; all other vertices will be assigned to core 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
    <tr><td class="paramname">k</td><td>The core value to be computed. </td></tr>
    <tr><td class="paramname">kmax</td><td>(Optional) The kmax value. If omitted then all cores are computed i.e., coreness. <em>This is not recommended for very large graphs.</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code><a class="el" href="classfg_1_1FG__vector.html" title="FlashGraph vector that provides several parallelized methods when compared to an STL-vector.   NOTE: Not an STL-compatible data structure. This vector is also ideally used with numeric data types.   Methods marked with the keyword parallel are parallelized implementations. ">FG_vector</a></code> containing the core of each vertex between <code>k</code> and <code>kmax</code>. All other vertices are assigned to core 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a793a72517715e336027303a530262e15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt;size_t&gt;::ptr fg::compute_local_scan </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the per-vertex local Scan Statistic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with an entry for each vertex in the graph's local scan value. </dd></dl>

</div>
</div>
<a class="anchor" id="acf48ab2f1f7661c8069dc21f6f00f8d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fg::compute_louvain </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>levels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute louvain clustering for a graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
    <tr><td class="paramname">levels</td><td>The number of levels of the hierarchy to do. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e618817474e258ce639d1a88947f684"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fg::compute_overlap </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; vertex_id_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>overlap_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the neighborhood overlap of each pair of vertices in `vids'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
    <tr><td class="paramname">vids</td><td>The vertices whose neighborhood overlap is computed. </td></tr>
    <tr><td class="paramname">overlap_matrix</td><td>A dense matrix that stores the overlap of each pair of vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e08e9f37c6433c7a77c1fdc6f05ca32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt;float&gt;::ptr fg::compute_pagerank </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>damping_factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the PageRank of a graph using the pull method where vertices request the data from all their neighbors each iteration. Tends to converge to stable values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
    <tr><td class="paramname">num_iters</td><td>The maximum number of iterations for PageRank. </td></tr>
    <tr><td class="paramname">damping_factor</td><td>The damping factor. Originally .85.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with an entry for each vertex in the graph's PageRank value. </dd></dl>

</div>
</div>
<a class="anchor" id="a6fc8c4d461a9c7f3b5bedb7627851925"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt;float&gt;::ptr fg::compute_pagerank2 </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>damping_factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the PageRank of a graph using the push method where vertices send deltas of their PageRank to neighbors in the event their own PageRank changes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
    <tr><td class="paramname">num_iters</td><td>The maximum number of iterations for PageRank. </td></tr>
    <tr><td class="paramname">damping_factor</td><td>The damping factor. Originally .85.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with an entry for each vertex in the graph's PageRank value. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d31b75e022b9784cade8eec88fe76fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt;vertex_id_t&gt;::ptr fg::compute_scc </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname"><em>fg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute all strongly connected components of a graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with a component ID for each vertex in the graph. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ecd96672b421904a5a4d5413537da1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sem_kmeans_ret::ptr fg::compute_sem_kmeans </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>max_iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Semi-External Memory kmeans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
    <tr><td class="paramname">k</td><td>The number of clusters. </td></tr>
    <tr><td class="paramname">init</td><td>Initialization type [random, forgy, kmeanspp]. </td></tr>
    <tr><td class="paramname">max_iters</td><td>The max number of iterations to compute for. </td></tr>
    <tr><td class="paramname">tolerance</td><td>The min fraction of changes from 1 iter to next required to converge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a096477f39527cdc1feaf88b52a549b8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt;vertex_id_t&gt;::ptr fg::compute_sync_wcc </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname"><em>fg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute all weakly connectected components of a graph synchronously. The reason of having this implementation is to understand the performance of synchronous wcc and asynchronous wcc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with a component ID for each vertex in the graph. </dd></dl>

</div>
</div>
<a class="anchor" id="a2051de108cc335b094326fff4f0f1f5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt;std::pair&lt;vertex_id_t, size_t&gt; &gt;::ptr fg::compute_topK_scan </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>topK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the top K vertices with the largest local Scan Statistic value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
    <tr><td class="paramname">topK</td><td>The value for K used for the <code>top K</code> vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of std::pair with an entry for each vertex in the top K together with its value. </dd></dl>

</div>
</div>
<a class="anchor" id="a8064fce1e91f417fb4128671c6f893f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt; float &gt;::ptr fg::compute_transitivity </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname"><em>fg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the transitivity/clustering coefficient of a graph. </p>
<p>Compute transitivity of all vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with an entry for each vertex in the graph's transitivity value.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with an transitivity value for each vertex. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cdbe4bcd2f983ca595d76a021a555b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt;vertex_id_t&gt;::ptr fg::compute_ts_wcc </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>start_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>time_interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute all weakly connectected components of a time-series graph in a specified time interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
    <tr><td class="paramname">start_time</td><td>The start time of the time interval. </td></tr>
    <tr><td class="paramname">time_interval</td><td>The length of the time interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with a component ID for each vertex in the graph. </dd></dl>

</div>
</div>
<a class="anchor" id="a51df06096e9cca18fb17faf00f32786a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt;size_t&gt;::ptr fg::compute_undirected_triangles </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname"><em>fg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute undirected triangle count for each vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector that contains the number of triangles associated with each vertex in the graph. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a08b5c608b7450cf964c5bb1128c935"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt;vertex_id_t&gt;::ptr fg::compute_wcc </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname"><em>fg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute all weakly connectected components of a graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with a component ID for each vertex in the graph. </dd></dl>

</div>
</div>
<a class="anchor" id="a53e5648d53863c4e07cddb792ba52d60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fg::estimate_diameter </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_bfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the diameter estimation for a graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The diameter estimate value. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b00d34d28ae5c8b26ab407e7e9a166a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">in_mem_subgraph::ptr fg::fetch_subgraph </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; vertex_id_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the clusters with the wanted cluster IDs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
    <tr><td class="paramname">vertices</td><td>The vertices that the induced subgraph has. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A subgraph. </dd></dl>

</div>
</div>
<a class="anchor" id="abf654728e855f5cd5d33e05ce73a1a8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt;<a class="el" href="namespacefg.html#ac4c90ec30f4ed5fda99401fc225d9bf2">vsize_t</a>&gt;::ptr fg::get_degree </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">edge_type&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the degree of all vertices in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
    <tr><td class="paramname">type</td><td>The edge type: IN_EDGE, OUT_EDGE, BOTH_EDGES. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with an entry for each vertex degree. </dd></dl>

</div>
</div>
<a class="anchor" id="ab87d33a7fb1ad68416eabade407ce556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;time_t, time_t&gt; fg::get_time_range </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname"><em>fg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the time range in which the time-series graph is. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of timestamp that defines the time range of the time-series graph. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8209ca51960ec08cbe98ce3e9678326"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfg_1_1FG__vector.html">FG_vector</a>&lt;<a class="el" href="namespacefg.html#ac4c90ec30f4ed5fda99401fc225d9bf2">vsize_t</a>&gt;::ptr fg::get_ts_degree </td>
          <td>(</td>
          <td class="paramtype">FG_graph::ptr&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">edge_type&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>start_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>time_interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the degree of all vertices in a specified time interval in a time-series graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fg</td><td>The FlashGraph graph object for which you want to compute. </td></tr>
    <tr><td class="paramname">type</td><td>The edge type: IN_EDGE, OUT_EDGE, BOTH_EDGES. </td></tr>
    <tr><td class="paramname">start_time</td><td>The start time of the time interval. </td></tr>
    <tr><td class="paramname">time_interval</td><td>length of the time interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with an entry for each vertex degree. </dd></dl>

</div>
</div>
<a class="anchor" id="abaa69bd003d3e8195c04a9ec16f3b0db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class ApplyFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fg::multi_vec_apply </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename FG_vector&lt; T &gt;::ptr &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename FG_vector&lt; T &gt;::ptr&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ApplyFunc&#160;</td>
          <td class="paramname"><em>apply</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a user defined function to multipl FG_vectors. <b>parallel</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputs</td><td>A vector of FG_vectors that are the inputs. </td></tr>
    <tr><td class="paramname">output</td><td>A <a class="el" href="classfg_1_1FG__vector.html" title="FlashGraph vector that provides several parallelized methods when compared to an STL-vector.   NOTE: Not an STL-compatible data structure. This vector is also ideally used with numeric data types.   Methods marked with the keyword parallel are parallelized implementations. ">FG_vector</a> that are the outputs. </td></tr>
    <tr><td class="paramname">apply</td><td>The user-defined function that will be applied to all vecotors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a40096428efe573d594aaaa9d031e3d45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vertex_id_t fg::MAX_VERTEX_ID = UINT_MAX</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to represent vertex IDs in graph </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Dec 13 2015 13:13:16 for FlashGraph-ng by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
