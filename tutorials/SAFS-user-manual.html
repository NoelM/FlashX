<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Programming interface &mdash; FlashX-docs 0.3 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="FlashX-docs 0.3 documentation" href="index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <p>SAFS is user space filesystem designed to access a large SSD array. The
goal of SAFS is to maximize the I/O performance of the SSD array on a
NUMA machine while still providing a filesystem interface to users. It
provides basic operations on files: create, delete, read and write. A
file exposed by SAFS is partitioned and each partition is stored as a
physical file on an SSD. SAFS currently does not support directory
operations. SAFSlib is a user-space C++ library that implements SAFS.</p>
<div class="section" id="programming-interface">
<h1>Programming interface<a class="headerlink" href="#programming-interface" title="Permalink to this headline">¶</a></h1>
<div class="section" id="file-metadata-operations">
<h2>File metadata operations<a class="headerlink" href="#file-metadata-operations" title="Permalink to this headline">¶</a></h2>
<p>The class <code class="docutils literal"><span class="pre">safs_file</span></code> represents an SAFS file and provides a few
methods for some metadata operations such as creating a file, deleting a
file and renaming a file.</p>
<pre>
class safs_file
{
public:
    /* The constructor method. The file doesn't need to exist. */
    safs_file(const RAID_config &conf, const std::string &file_name);
    /* Test whether the SAFS file exists. */
    bool exist() const;
    /* Get the size of the SAFS file. */
    ssize_t get_size() const;
    /* Create the SAFS file with the specified size. */
    bool create_file(size_t file_size);
    /* Delete the SAFS file. */
    bool delete_file();
    /* Rename the SAFS file to a new name. */
    bool rename(const std::string &new_name);
};
</pre><p>SAFS does not support directories. The function <code class="docutils literal"><span class="pre">get_all_safs_files</span></code>
returns all files in SAFS.</p>
<pre>
size_t get_all_safs_files(std::set<std::string> &files);
</pre></div>
<div class="section" id="file-access">
<h2>File access<a class="headerlink" href="#file-access" title="Permalink to this headline">¶</a></h2>
<p>Two classes (<code class="docutils literal"><span class="pre">file_io_factory</span></code> and <code class="docutils literal"><span class="pre">io_interface</span></code>) are used for
accessing data in a file. The class <code class="docutils literal"><span class="pre">file_io_factory</span></code> creates and
destroys <code class="docutils literal"><span class="pre">io_interface</span></code> objects, which provides methods to read and
write an SAFS file. An <code class="docutils literal"><span class="pre">io_interface</span></code> instance can only access a
single file and can only be used in a single thread. We intentionally
make the implementations of <code class="docutils literal"><span class="pre">io_interface</span></code> <strong>not thread-safe</strong> for the
sake of performance.</p>
<div class="section" id="file-open-and-close">
<h3>File open and close<a class="headerlink" href="#file-open-and-close" title="Permalink to this headline">¶</a></h3>
<p>The function <code class="docutils literal"><span class="pre">create_io_factory</span></code> creates a <code class="docutils literal"><span class="pre">file_io_factory</span></code>
instance for a file. It allows a user to specify an access option, which
decides what type of the <code class="docutils literal"><span class="pre">file_io_factory</span></code> instance is created. Right
now, SAFS supports two access options:</p>
<ul class="simple">
<li>REMOTE_ACCESS: this corresponds to direct I/O in Linux. The
<code class="docutils literal"><span class="pre">io_interface</span></code> instance created by such a <code class="docutils literal"><span class="pre">file_io_factory</span></code>
doesn&#8217;t use page cache in SAFS.</li>
<li>GLOBAL_CACHE_ACCESS: this corresponds to buffered I/O in Linux. The
<code class="docutils literal"><span class="pre">io_interface</span></code> instance uses page cache in SAFS.</li>
</ul>
<p>Opening a file involves in two steps: invoking <code class="docutils literal"><span class="pre">create_io_factory</span></code> to
create a <code class="docutils literal"><span class="pre">file_io_factory</span></code> object; invoking the <code class="docutils literal"><span class="pre">create_io</span></code> method
of <code class="docutils literal"><span class="pre">file_io_factory</span></code> to create an <code class="docutils literal"><span class="pre">io_interface</span></code> object. Files are
closed implicitly when the <code class="docutils literal"><span class="pre">file_io_factory</span></code> object is destroyed.</p>
</div>
<div class="section" id="synchronous-read-and-write">
<h3>Synchronous read and write<a class="headerlink" href="#synchronous-read-and-write" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line">A user can use the following method of <code class="docutils literal"><span class="pre">io_interface</span></code> to issue
synchronous I/O requests. <code class="docutils literal"><span class="pre">access_method</span></code> determines whether it is a
read or write request: 0 indicates read and 1 indicates write.</div>
<div class="line"><br /></div>
<div class="line">class io_interface</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">io_status access(char *buf, off_t off, ssize_t size, int
access_method);</div>
<div class="line">...</div>
<div class="line">};</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="asynchronous-read-and-write">
<h3>Asynchronous read and write<a class="headerlink" href="#asynchronous-read-and-write" title="Permalink to this headline">¶</a></h3>
<p>Users can use the following set of methods to use asynchronous I/O.
First, users need to implement the <code class="docutils literal"><span class="pre">callback</span></code> interface and register
it to an <code class="docutils literal"><span class="pre">io_interface</span></code> object to get notification of completion of
I/O requests before issuing any I/O requests. Then, they use the
asynchronous version of the <code class="docutils literal"><span class="pre">access</span></code> method to issue I/O requests.
When a request completes, the <code class="docutils literal"><span class="pre">callback</span></code> is invoked. It is guaranteed
that the <code class="docutils literal"><span class="pre">callback</span></code> object will be invoked in the same thread where
the object is associated to. An <code class="docutils literal"><span class="pre">io_interface</span></code> instance does not limit
the number of parallel I/O requests that can be issued to it. Users need
to monitor and limit the number of incomplete I/O requests themselves.</p>
<pre>
class io_interface
{
public:
    ...
    /* Issue asynchronous I/O requests. */
    void access(io_request *, int, io_status *);
    /* Flash I/O requests buffered by the io_interface instance. */
    void flush_requests();
    /* Wait for at least the specified number of I/O requests to complete. */
    int wait4complete(int);
    /* Get the number of pending I/O requests. */
    int num_pending_ios() const;
    /* set the callback function. */
    bool set_callback(callback *);
};
</pre><pre>
class callback
{
public:
    virtual int invoke(io_request *reqs[], int num) = 0;
};
</pre></div>
</div>
<div class="section" id="a-simple-example-of-using-the-library">
<h2>A simple example of using the library<a class="headerlink" href="#a-simple-example-of-using-the-library" title="Permalink to this headline">¶</a></h2>
<p>The following pseudocode illustrates a simple use case of SAFS, which
uses its synchronous I/O interface to read data from a file.</p>
<pre>
config_map::ptr configs = config_map::create(conf_file);
init_io_system(configs);
file_io_factory::shared_ptr factory = create_io_factory(graph_file,
        REMOTE_ACCESS);
io_interface::ptr io = factory->create_io(
        thread::get_curr_thread());

char *buf = NULL;
size_t buf_capacity = 0;
BOOST_FOREACH(task t, tasks) {
    // This is directed I/O. Memory buffer, I/O offset and I/O size
    // all need to be aligned to the I/O block size.
    size_t io_size = ROUNDUP_PAGE(t.get_size());
    data_loc_t loc(factory->get_file_id(), t.get_offset());
    if (io_size > buf_capacity) {
        free(buf);
        buf_capacity = io_size;
        buf = (char *) valloc(buf_capacity);
    }
    assert(buf_capacity >= io_size);
    io_request req(buf, loc, io_size, READ);
    io->access(&req, 1);
    io->wait4complete(1);
    run_computation(buf, t.get_size());
}
free(buf);
</pre><p>The following pseudocode illustrates a use case of SAFS&#8217; asynchronous
I/O interface to read data from a file. It is slightly more complex than
the synchronous I/O interface. It requires to define a callback class
and the computation is performed in the callback class.</p>
<pre>
class multiply_callback: public callback
{
    const std::vector<task> &tasks;
public:
    multiply_callback(const std::vector<task> &_tasks): tasks(_tasks) {
    }

    virtual int invoke(io_request *reqs[], int num);
};

struct comp_task
{
    bool operator()(const task &t1, const task &t2) const {
        return t1.get_offset() < t2.get_offset();
    }
};

int multiply_callback::invoke(io_request *reqs[], int num)
{
    for (int i = 0; i < num; i++) {
        off_t off = reqs[i]->get_offset();
        ext_mem_vertex_info info(0, off, 0);
        std::vector<task>::const_iterator it = std::lower_bound(
                tasks.begin(), tasks.end(),
                task(info), comp_task());
        assert(it != tasks.end());
        assert(it->get_offset() == off);
        char *buf = reqs[i]->get_buf();
        run_multiply(buf, it->get_size());
        free(buf);
    }
    return 0;
}

config_map::ptr configs = config_map::create(conf_file);
init_io_system(configs);
file_io_factory::shared_ptr factory = create_io_factory(graph_file,
        REMOTE_ACCESS);
io_interface::ptr io = factory->create_io(thread::get_curr_thread());
io->set_callback(new multiply_callback(tasks));

int max_ios = 20;
BOOST_FOREACH(task t, tasks) {
    while (io->num_pending_ios() >= max_ios)
        io->wait4complete(1);

    // This is directed I/O. Memory buffer, I/O offset and I/O size
    // all need to be aligned to the I/O block size.
    size_t io_size = ROUNDUP_PAGE(t.get_size());
    data_loc_t loc(factory->get_file_id(), t.get_offset());
    char *buf = (char *) valloc(io_size);
    io_request req(buf, loc, io_size, READ);
    io->access(&req, 1);
}
io->wait4complete(io->num_pending_ios());
</pre></div>
<div class="section" id="utility-tool-in-safs">
<h2>Utility tool in SAFS<a class="headerlink" href="#utility-tool-in-safs" title="Permalink to this headline">¶</a></h2>
<p>SAFS-util is a tool that helps to manage SAFS. It provides a few
commands to operate SAFS:</p>
<ul class="simple">
<li>create: create a file in SAFS.</li>
<li>delete file_name: delete a file in SAFS.</li>
<li>list: list all existing files in SAFS.</li>
<li>load: load a file from an external filesystem to a file in SAFS.</li>
<li>verify: verify the data of a file in SAFS. It’s mainly used for
testing.</li>
</ul>
</div>
</div>
<div class="section" id="configurations">
<h1>Configurations<a class="headerlink" href="#configurations" title="Permalink to this headline">¶</a></h1>
<div class="section" id="system-configurations-for-safs">
<h2>System configurations for SAFS:<a class="headerlink" href="#system-configurations-for-safs" title="Permalink to this headline">¶</a></h2>
<p>SAFS requires proper system configurations to get the maximal
performance from an SSD array. It includes evenly distributing
interrupts to all CPU cores and using the noop I/O scheduler;</p>
<p>The following two scripts automate the process.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">conf/set_affinity.sh</span></code>: The script disables irqbalance and
distributes IRQs (Interrupt Requests) to CPU cores evenly. It is only
required when we run SAFS on a NUMA machine, and it is written for an
LSI host bus adapter (HBA). For other HBAs, users need to adapt the
script for their specific hardware.</li>
<li><code class="docutils literal"><span class="pre">conf/set_ssds.pl</span></code>: The script takes an input file that contains
device files to run SAFS on. The input file has a device file on each
line. The script identifies the SSDs that connect to the same HBA
controller, and assigns all SSDs in the same HBA to the same NUMA
node. It sets I/O request affinity for each device file to <code class="docutils literal"><span class="pre">2</span></code> to
force the request completion on the requesting CPU core. It
configures each device file to use the noop I/O scheduler. Then it
mounts SSDs to the system, and creates conf/data_files.txt, which is
used as the configuration file of the root directories by the
library. In conf/data_files.txt, each line has the format:
<code class="docutils literal"><span class="pre">node_id:path_to_mountpoint</span></code>.</li>
</ul>
</div>
<div class="section" id="the-configurations-in-safs">
<h2>The configurations in SAFS<a class="headerlink" href="#the-configurations-in-safs" title="Permalink to this headline">¶</a></h2>
<p>SAFS defines the following parameters for users to customize SAFS. When
SAFS is initialized, users have the opportunity to set them.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">root_conf</span></code>: a config file that specifies the directories on SSDs
where SAFS files are stored. The config file has a line for each
directory and the format of each line is
<code class="docutils literal"><span class="pre">node_id:path_of_directory</span></code>.</li>
<li><code class="docutils literal"><span class="pre">RAID_block_size</span></code>: defines the size of a data block on an SSD.
Users can specify the size with the format x(k, K, m, M, g, G). e.g.,
4k = 4096 bytes. The default block size is 512KB.</li>
<li><code class="docutils literal"><span class="pre">RAID_mapping</span></code>: defines how data blocks of a file are mapped to
SSDs. Currently, the library provides three mapping functions: RAID0,
RAID5, HASH. The default mapping is RAID5.</li>
<li><code class="docutils literal"><span class="pre">cache_size</span></code>: define the size of the page cache. It uses the format
of x(k, K, m, M, g, G). The default cache size is 512MB.</li>
<li><code class="docutils literal"><span class="pre">num_nodes</span></code>: defines the number of NUMA nodes where the page cache
is allocated. The default number is 1.</li>
<li><code class="docutils literal"><span class="pre">virt_aio</span></code>: enable virtual AIO for debugging and performance
evaluation. It is mainly used for testing when SSDs are not
available. By default, it’s not enabled.</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Programming interface</a><ul>
<li><a class="reference internal" href="#file-metadata-operations">File metadata operations</a></li>
<li><a class="reference internal" href="#file-access">File access</a><ul>
<li><a class="reference internal" href="#file-open-and-close">File open and close</a></li>
<li><a class="reference internal" href="#synchronous-read-and-write">Synchronous read and write</a></li>
<li><a class="reference internal" href="#asynchronous-read-and-write">Asynchronous read and write</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-simple-example-of-using-the-library">A simple example of using the library</a></li>
<li><a class="reference internal" href="#utility-tool-in-safs">Utility tool in SAFS</a></li>
</ul>
</li>
<li><a class="reference internal" href="#configurations">Configurations</a><ul>
<li><a class="reference internal" href="#system-configurations-for-safs">System configurations for SAFS:</a></li>
<li><a class="reference internal" href="#the-configurations-in-safs">The configurations in SAFS</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/SAFS-user-manual.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Da Zheng.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
      |
      <a href="_sources/SAFS-user-manual.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>